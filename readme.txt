    AP Computer Science Final Project - README Template
Instructions:
The first step in creating an excellent APCS final project is to write up a README. At this stage, this README file acts as your project proposal. Once you’ve filled in all components, Shelby will read through it and suggest edits. Ultimately, you need a document that adequately describes your project idea and we must agree on this plan.
Have one member of your group make a copy of this Google Doc. Then, they should share it with all other members so that every group member has edit permissions.
There’s a lot of parts of this document that you might not have full answers for yet. Because you haven’t written the program yet, it’s difficult to think about the instructions or which group members will do which parts. Even though this is hard to think about, you must have something in these sections that act as your current plan. However, during the course of the project, you’ll continuously update this document. This means that you will not be held to exactly what you put here - components of this document can change (and it’s pretty common!).
There is one exception: the Features List section. Once Shelby OKs your README, the Features List section cannot be modified. For this reason, it is most important that you get a solid idea of what you want to make and the primary features it will have now.
Talk with your group. Consider drawing some pictures of what you think your project might look like. Be precise. When you’re ready, fill this out together. Each component in brackets below ( [these things] ) should be replaced with your ideas. Note that there are several sample READMEs posted on this assignment for you to use as guidance.
-------------------When README is finalized, remove everything above this line--------------------

Authors: Ethan, Han, John
Revision: 4/10/20
AP Computer Science Final Project - README Template
Instructions:
The first step in creating an excellent APCS final project is to write up a README. At this stage, this README file acts as your project proposal. Once you’ve filled in all components, Shelby will read through it and suggest edits. Ultimately, you need a document that adequately describes your project idea and we must agree on this plan.
Have one member of your group make a copy of this Google Doc. Then, they should share it with all other members so that every group member has edit permissions.
There’s a lot of parts of this document that you might not have full answers for yet. Because you haven’t written the program yet, it’s difficult to think about the instructions or which group members will do which parts. Even though this is hard to think about, you must have something in these sections that act as your current plan. However, during the course of the project, you’ll continuously update this document. This means that you will not be held to exactly what you put here - components of this document can change (and it’s pretty common!).
There is one exception: the Features List section. Once Shelby OKs your README, the Features List section cannot be modified. For this reason, it is most important that you get a solid idea of what you want to make and the primary features it will have now.
Talk with your group. Consider drawing some pictures of what you think your project might look like. Be precise. When you’re ready, fill this out together. Each component in brackets below ( [these things] ) should be replaced with your ideas. Note that there are several sample READMEs posted on this assignment for you to use as guidance.
-------------------When README is finalized, remove everything above this line--------------------

Authors: Ethan, Han, John
Revision: 4/10/20
Introduction: 
[In a few paragraphs totaling about ½ page, introduce the high-level concept of your program. What this looks like depends a lot on what type of thing you are making. An introduction for an application will look different than one for a game. In general, your introduction should address questions like these:
What does your program do?
The program is a game that allows people to play a bullet-hell game.
What problem does it solve? Why did you write it?
It addresses the issue of being noted during quarantine, giving the player a way to pass time in what is hopefully a demanding challenge.
What is the story?
There is no story related to this game, as it is designed more so for the challenge of a bullet hell experience than for plot. As such, the plot is not the focus of this APCS final project.
What are the rules? What is the goal?
The player must try and survive as long as possible, eliminating both players and AI enemies, and grazing bullets to increase their score. If they get hit by a bullet once, they lose the game and must rejoin to play, starting back to 0 progress.
Who would want to use your program?
People who are sufficiently bored enough (like in quarantine) and would want a simple competitive experience will want to play this game, as well as those who wish to see how their skills in coordination and prediction.
Professional bullet hell players who want a tournament-style means to measure skill can use this program to compete with other players, measuring skill in evasion and strategy over just survival time.
What are the primary features of your program?
The primary focus of this program is replicating the bullet-hell game genre, which includes a large number of moving projectiles on the screen. If time allows, a multiplayer option would be implemented, although single player survival is the primary gamemode of this project.

Instructions:
Explain how to use the program. This needs to be specific: 
Which keyboard keys will do what?
You will use WASD to move your player around, with the mouse controlling the point-and-click aiming system for shooting. There will also be a user interface in which the user must use the mouse to navigate the title screen. 
Where will you need to click? 
The title screen UI will have specific buttons that must be pressed to launch the game mode, while the main gameplay will allow the player to click anywhere on the map to aim their attacks.
Will you have menus that need to be navigated? What will they look like? 
There will be a main title screen for the player to navigate as a menu. Even though a pause menu and options menu are standard per game design, only the title screen will be a mandatory menu (like how .io games typically lack pause menus)
Do actions need to be taken in a certain order?
First the player will have to navigate a title menu screen before being able to play any game mode, from which they will now move with WASD keys and use the mouse to point and shoot in a certain direction.

Features List (THE ONLY SECTION THAT CANNOT CHANGE LATER):
Must-have Features:
[These are features that we agree you will definitely have by the project due date. A good final project would have all of these completed. At least 5 are required. Each feature should be fully described (at least a few full sentences for each)]
 A moveable character that is controlled by the player. The player would have to control the character and prevent losing life points. 
Projectiles are easily the most important component in the game, as the screen will often be covered by these for difficulty and challenge.
 In order to make the game more difficult, we will also have enemies that attack the player. These enemies will attempt to damage the player until the player dies. 
In order to add some progression, the enemies will become harder as the player progresses through the game.  
We will also have a scoring mechanism. As the player progresses, the game will keep track of how many points they have gained and store the highest score. 
Points increase from certain collectibles (which are in turn dropped by defeated enemies or other players), and through grazing (getting close to bullets but not to the point where they deal damage). Likewise, score is lost with each hit taken.
A title screen is required for the player to navigate prior to launching the main game campaign.




Want-to-have Features:
[These are features that you would like to have by the project due date, but you’re unsure whether you’ll hit all of them. A good final project would have perhaps half of these completed. At least 5 are required. Again, fully describe each.]
A good feature to have would be to have multiple enemies where a different type of enemy would do different amounts of damage and attack in different patterns
Instead of an endless game, the game would have multiple levels that featured a different map, enemies, and weapons.
Powerups would be given to the player to grant them special abilities and make them more powerful. 
 Weapons to add variety to the game which would do varying amounts of damage and have their own bullet and attack speed.

Stretch Features:
[These are features that we agree a fully complete version of this program would have, but that you probably will not have time to implement. A good final project does not necessarily need to have any of these completed at all. At least 3 are required. Again, fully describe each.]
Multiplayer would include another player able to join them either by networking or locally on the keyboard. 
 Bosses would be a very hard enemy to act as the final challenge before finishing a level, perhaps even having multiple life bars with their own unique patterns for added challenge.
Character Selection would feature multiple characters that the player can choose from and they would each have their unique set of abilities.

Class List:
[This section lists the Java classes that make up the program and very briefly describes what each represents. It’s totally fine to put this section in a list format and not to use full sentences.]
Actor
    Projectile
        Asteroid
    GameCharacter
        Enemy
        Player
Runner
Screen (Abstract)
    FirstScreen
    SecondScreen
DrawingSurface
Screen Switcher(Interface)
DamagableImterface(Interface)
Main

Credits:
[Gives credit for project components. This includes both internal credit (your group members) and external credit (other people, websites, libraries). To do this:
List the group members and describe how each member contributed to the completion of the final program. This could be classes written, art assets created, leadership/organizational skills exercises, or other tasks. Initially, this is how you plan on splitting the work.
Han: Created framework for GameCharacter, Player, Asteroid, and Projectile, create DamagableInterface, Implement Shooting, updated UML and ReadMe as needed.
John: Created the base actor class, created all necessary assets for the game, helped with implementing shooting and movement.
Ethan: Handle Main Menu, Player point counter (part of the UI), Main Menu screen, and the Drawing Surface on which the graphics are drawn.
Give credit to all outside resources used. This includes downloaded images or sounds, external java libraries, parent/tutor/student coding help, etc.]
We used Mr. Shelby’s MovingImage class to help code for the entities. 
We also used some super classes from our previous projects
Our Icon for the game itself is a stock image of a space ship.
